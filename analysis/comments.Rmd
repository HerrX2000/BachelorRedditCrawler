---
title: "Comments - Study I"
author: "Frederik Mann"
date: "15 7 2021"
output:
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
Sys.setenv(LANG = "en")
```

## Comments


```{r libs}
options(repos='http://cran.rstudio.com/')
library(pacman)
month_abb <- c(1,2,3,4,5,6,7,8,9,10,11,12)
p_load(RColorBrewer, # color pallets
       ggplot2, # reportable graphs
       cowplot, # arranges ggplot graphs nicely
       stargazer,
       MASS,
       DescTools,
       dplyr,
       psych,
       svglite,
       irr,
       moments) 
```

### Import data set
```{r import, cache=TRUE, cache.lazy = FALSE}
df <- read.csv(paste("data/comments/comments_subs_20_",1,"_",month.name[1],"_0.csv", sep=""))
for (month in 2:12){
  df_month <- read.csv(paste("data/comments/comments_subs_20_",month,"_",month.name[month],"_0.csv", sep=""))
  df <- rbind(df, df_month)
}
```

### Inspect Data
```{r inspect}
str(df)
#correct datatypes
df$is_submitter <- as.logical(df$is_submitter)
df$send_replies <- as.logical(df$send_replies)
df$subreddit <- as.factor(df$subreddit)
df$no_follow <- as.logical(df$no_follow)
df$stickied <- as.logical(df$stickied)
df$locked <- as.logical(df$locked)
df$subreddit <- as.factor(df$subreddit)
df$date <- as.Date(df$datetime)

#removing unused columns
df$all_awardings <- NULL #JSON Object
df$associated_award <- NULL #Not reliably provided by Pushshift
df$author_created_utc <- NULL #Epoch time stamp when a author created his account but not reliably provided by Pushshift
df$author_fullname <- NULL #Unqiue identifier of author, but author name is already unqiue
df$awarders <- NULL #Not used for any analysis
df$body <- NULL #Not used for any analysis
df$collapsed_because_crowd_control <- NULL #If a comment receives too much downvotes it is collapsed by default, sadly the value is not provided reliably by Pushshift
df$subreddit_id <- NULL #Subreddit name is already unqiue
df$gildings <- NULL #Before Awards existed or somethine? not used for analysis
df$is_submitter <- NULL #Purpose and meaning unknown
df$steward_reports <- NULL

#Data is accurate but should be part of the subs not the individual comments
#df$is_city <- NULL
#df$is_country <- NULL 
df$is_country_native <- NULL
df$is_country_english <- NULL
df$is_country_bi <- NULL
#df$is_continent <- NULL
df$group <- ifelse(df$is_continent == TRUE, 1, ifelse(df$is_country == TRUE, 2, 3))

str(df)
```

### Categorization of subreddits
```{r import_categorization}
sub_meta <- read.csv("data/subreddits.csv")
sub_meta$subreddit <- as.factor(sub_meta$subreddit)
str(sub_meta)
```

### Preprocess: Treat missing values, if applicable
```{r preprocess}
#Authors missing value was either "" or "[deleted]". Reason unknown. Both ommited later.
df$author[df$author == ""] <- NA
df$author[df$author == "[deleted]"] <- NA

sum(is.na(df$author))
(sum(is.na(df$author))) / nrow(df)


#Check for number and % of duplicate id. Turned out to be 0.
sum(duplicated(df$id))
(sum(duplicated(df$id))) / nrow(df)
df <-df[!duplicated(df$id), ]

#Check for number and % of stickied posts. Sadly not returned correctly by pushshift.
#Stickied comments are shown at the very top of a post. They are usually reminders by moderators to follow the rules of a subreddit and should not be analysed seen as regular comments.
sum(df$stickied == TRUE)
(sum(df$stickied == TRUE)) / nrow(df)
df <- df[!(df$stickied == TRUE),]


str(df)
```
### Data Set Stats
```{r stats_dataset}
#For appendix and summary of dataset
#Contributions pro Subreddit
df_sub_con <- df %>% count(subreddit)
df_sub_con

#Unique Contributors pro Subreddit
df_sub_uc <- df %>%
  group_by(subreddit) %>%
  summarise(unique_contributors = n_distinct(author))
df_sub_uc

#Mean and standard deviation
mean(df_sub_uc$unique_contributors)
sd(df_sub_uc$unique_contributors) 
```

### Calculations
```{r calculations_1}
# to_interval
# @param anchor.date   Anchor date used to determine what interval the date belongs to
# @param future.date   The date whoms interval should be determined
# @param interval.days The interval size

to_interval <- function(anchor.date, future.date, interval.days){
  round(as.integer(future.date - anchor.date) / interval.days, 0)+1 #interval starts at 1
}

#Apply interval to each df$data
df$interval <- to_interval(as.Date('2020-01-01'), 
                          df$date, 14 )

###Alternative methode. Not used.
###df$month <- format(df$date, "%m")
###df$month <- factor(df$month) #another way of making intervals, but not used in analysis.
###data.frame(table(df$month))

#Check if interval works correctly
#Interval 1: New years effect
#Interval 7: Start of covid pandemic
#Interval 23: US Election
#Interval 27: Incomplete + new years/christmas effect. Ommited later.

dfwi <- data.frame(table(df$interval))
dfwi



#?
tbl <- with(df, table(subreddit, interval))
ggplot(as.data.frame(tbl), aes(factor(interval), Freq, fill = subreddit)) +     
  geom_col(position = 'dodge')
#?

#Overall
Gini(dfwi$Freq)

#DF only with authors that are known and not deleted
nrow(df)
df_with_acc <- df[!is.na(df$author),]
nrow(df_with_acc)

#df_with_acc <- df_with_acc[df_with_acc$score > 10,]

 
#artifical id for tables
id <- 0

#df with calculated values
df_subs <- data.frame(
                 id=factor(),
                 interval=character(),
                 gini_comment_dist=double(),
                 gini_score_dist=double(),
                 subreddit=factor(levels = levels(df_with_acc$subreddit)),
                 contributors = integer(),
                 total_comments = integer(),
                 turnover = double(),
                 stringsAsFactors=TRUE
                 )

#calculating for each subreddit each interval
for (subreddit in levels(df_with_acc$subreddit)){
  #DF for subreddit x
  df_subreddit <- df_with_acc[df_with_acc$subreddit == subreddit, ]
  df_author_prev_interval <- NULL
  
  #Last interval omit because it was not a full interval
  for (interval in head( unique(df_subreddit$interval), -1)){
    #Get df for the interval
    df_7day <- df_subreddit[df_subreddit$interval == interval, ]
    
    if(nrow(df_7day) == 0){
      #This should never occure and is here so the script does not crash when loading the data partially
      warning("Empty interval")
      next
    }
    
    #Posts per Author
    df_author_comments <- (df_7day %>% count(author))
    
    #Sum of score per author
    df_author_score <- aggregate(df_7day$score, by=list(author=df_7day$author), FUN=sum)
    
    #Both merged
    df_author <- merge(df_author_comments, df_author_score, by="author")
    
    df_author$score_per_comment <- df_author$x / df_author$n #Average comment score. NOT USED.
    #df_author$perc_of_total_comments <- df_author$freq / length(df_author)
    "
    To calculate the coefficient, we divided 
    the average difference in the number of comments posted by 
    each possible pair of users who contributed to a given sub-
    reddit during a given month by the number of UCs for that 
    month in that subreddit.
    (see ref paper)
    where xi = number of comments by UC in a given month in a 
    given subreddit and n = number of UCs in a given month in a 
    given subreddit.
    "
    gini_comment_dist <- Gini(df_author$n)
    

    gini_score_dist <- Gini(df_author$score_per_comment) #NOT USED.
    
    "
    Turnover  was  determined  by  comparing  a  list  of  
    UCs who contributed to discourse in a given subreddit dur-
    ing  a  given  month  to  a  list  of  UCs  who  contributed  to  dis-
    course in that same subreddit during the subsequent month. 
    Our  turnover  metric  is  an  expression  of  the  percentage  of  
    UCs  that  are  not  retained  from  one  month  to  the  next  in  a  
    given subreddit.
    (see ref paper)
    where  UCi = UCs  in  month  i  and  UCi+1  =  UCs  in  the  month  
    after month i.
    If all UCs who contributed to discourse in the first month 
    also contributed in the second month, turnover was equal to 
    0. If no UCs who contributed to discourse in the first month 
    also contributed in the second month, turnover was equal to 
    1 (M = .65;  SD = .13).
    "
    
    turnover <- double()
    if(is.null(df_author_prev_interval)){
      turnover <- NA #Firsts interval turnover can not be calculated
    }
    else{
      df_author_intersect <- intersect(df_author$author, df_author_prev_interval) #Intersect with prev interval
      turnover <- 1 - (length(df_author_intersect) / length(df_author$author)) #Percantage of turnover.
    }

    #df for sub
    df_sub <- data.frame(
                   id=id,
                   interval=interval,
                   gini_comment_dist=gini_comment_dist,
                   gini_score_dist=gini_score_dist,
                   subreddit=subreddit,
                   contributors = length(unique(df_7day$author)),
                   total_comments = length(df_7day$id),
                   turnover = turnover,
                   stringsAsFactors=TRUE
                   )
    id <- id + 1
    #for turnover calc
    df_author_prev_interval <- df_author$author
    #add calculation to df for subs
    df_subs <- rbind(df_subs, df_sub)
  }
}
```
### Calculations
```{r calculations_2}
#df_subs$avg_contributors <- aggregate(df_subs$contributors, by=list(subreddit=df_subs$subreddit), FUN=mean)

#Add categorisation to the df for subs
"
df_subs$is_city <- sub_meta$is_city[sub_meta$subreddit == df_subs$subreddit]
df_subs$is_country <- sub_meta$is_country[sub_meta$subreddit == df_subs$subreddit]
df_subs$is_country_native <- sub_meta$is_country_native[sub_meta$subreddit == df_subs$subreddit]
df_subs$is_country_english <- sub_meta$is_country_english[sub_meta$subreddit == df_subs$subreddit]
df_subs$is_country_bi <- sub_meta$is_country_bi[sub_meta$subreddit == df_subs$subreddit]
df_subs$is_continent <- sub_meta$is_continent[sub_meta$subreddit == df_subs$subreddit]
"

df_subs <- merge(df_subs, sub_meta, by="subreddit", fill=NA)
df_subs$group <- ifelse(df_subs$is_continent == TRUE, 1,
                        ifelse(df_subs$is_country == TRUE,
                               ifelse(df_subs$is_country_english == TRUE, 2.1,
                                      ifelse(df_subs$is_country_bi == TRUE, 2.2, 2.3)
                               ),3))

df_subs$group <- as.factor(df_subs$group)

str(df_subs)

#contributors log transofrmed (unique commenters in ref paper)
df_subs$log_contributors <- log(df_subs$contributors)
```

### Calculated Subreddit Data Set Stats
```{r stats_subreddits}
mean(df_subs$contributors)
sd(df_subs$contributors) 

print("Min/Max")
min(df_subs$contributors)
max(df_subs$contributors)

print("is_city")    
mean(df_subs$contributors[df_subs$is_city])
sd(df_subs$contributors[df_subs$is_city]) 

print("is_country")    
mean(df_subs$contributors[df_subs$is_country])
sd(df_subs$contributors[df_subs$is_country]) 

print("is_continent")
mean(df_subs$contributors[df_subs$is_continent])
sd(df_subs$contributors[df_subs$is_continent]) 

print("skewness")
skewness(df_subs$contributors)
kurtosis(df_subs$contributors)
```


### Data Visualisation
```{r visualisation, eval = TRUE}


df_subs$interval <-as.numeric(as.character(df_subs$interval))

category_colors <- c("1" = "#000000", "2.1" = "#000099", "2.2" ="#1144bb", "2.3" = "#5577EE", "3" = "#e6ac00")
category_labels <- c("1" = "Continent", "2.1" = "Country English", "2.2" ="Country Bilingual", "2.3" = "Country Native", "3" = "City")

ggplot(df_subs, aes(x = reorder(id, contributors), y = contributors, color = group)) +
  geom_bar(stat = "identity") +
  scale_color_manual(name = "Group", values=category_colors, labels=category_labels) +
  ggtitle("UC/Interval Distribution")+
  ylab("UC/Interval") +
  xlab("Datapoints ordered by UC")+
  theme(axis.text.x=element_blank(), #remove x axis labels
        axis.ticks.x=element_blank(), #remove x axis ticks
        )


ggsave(path = "comments_files/figure-svg/", filename = "datapoint_ordered_uc.svg", device='svg')
ggsave(path = "comments_files/figure-png/", filename = "datapoint_ordered_uc.png", device='png')

ggplot(df_subs, aes(x=interval, y=gini_comment_dist, group = group, color = subreddit)) +
  geom_point() 

"
ggplot(df_subs, aes(x=interval, y=gini_score_dist, group = group, color = subreddit)) +
  geom_point() 
"

ggplot(df_subs, aes(x=interval, y=contributors, group = group, color = subreddit)) +
  geom_point()

ggplot(df_subs, aes(x=interval, y=total_comments, group = group, color = subreddit)) +
  geom_point()

ggplot(df_subs[!is.na(df_subs$turnover),], aes(x=interval, y=turnover, group = group, color = subreddit)) +
  geom_point()

str(df_subs)
summary(df_subs)
```
### Testing ANOVA / 
```{r anova}
#https://www.youtube.com/watch?v=GctGncQrJew
#describeBy(df_subs$gini_comment_dist, df_subs$subreddit)
df_subs_cities <- df_subs[df_subs$is_city==TRUE,]
summary(aov(df_subs$gini_comment_dist ~ df_subs$subreddit))
pairwise.t.test(df_subs_cities$gini_comment_dist, df_subs_cities$subreddit)


#describeBy(df_subs_cities$turnover, df_subs_cities$subreddit)
#summary(aov(df_subs$turnover ~ df_subs$subreddit))
#pairwise.t.test(df_subs_cities$turnover, df_subs_cities$subreddit)

```

```{r}
#icc(df_subs,type = "agreement", unit = "single")
```


### Models
```{r models, eval = TRUE}
#For LMs checking for group effect is_english_county is the reference.

mean(df_subs$gini_comment_dist)

category_colors <- c("1" = "#000000", "2.1" = "#000099", "2.2" ="#1144bb", "2.3" = "#5577EE", "3" = "#e6ac00")
category_labels <- c("1" = "Continent", "2.1" = "Country English", "2.2" ="Country Bilingual", "2.3" = "Country Native", "3" = "City")

ggplot(df_subs, aes(x=contributors, y=gini_comment_dist, group = NULL, color = NULL)) +
  geom_point(aes(color=factor(group))) +
  geom_smooth(method='lm', formula= y~x) +
  scale_x_continuous(trans='log2') +
  ylim(0,1) +
  ggtitle("UCs predicting concentration of participation")+
  ylab("Concentration of participation (Gini)") +
  xlab("Unique contributors/Interval (log2)")+
  scale_color_manual(name = "Group", values=category_colors, labels=category_labels)


ggsave(path = "comments_files/figure-svg/", filename = "gini_distribution.svg", device='svg')
ggsave(path = "comments_files/figure-png/", filename = "gini_distribution.png", device='png')

ggplot(df_subs[df_subs$subreddit=="berlin",], aes(x=interval, y=gini_comment_dist, group = NULL, color = NULL)) +
  geom_point(aes(color=factor(interval))) +
  geom_smooth(method='lm', formula= y~x) +
  scale_x_continuous(trans='log2') +
  ylim(0,1) +
  ggtitle("UCs predicting concentration of participation")+
  ylab("Concentration of participation (Gini)") +
  xlab("Unique contributors/Interval (log2)")

ggsave(path = "comments_files/figure-png/", filename = "1.png", device='png')

lm_model <- lm(gini_comment_dist ~ log_contributors + interval, data = df_subs)
summary(lm_model)

lm_model <- lm(gini_comment_dist ~ log_contributors + interval + is_city + is_country_native + is_country_bi + is_continent  , data = df_subs)
summary(lm_model)



"
ggplot(df_subs, aes(x=contributors, y=gini_score_dist, group = group, color = subreddit)) +
  geom_point() +
  geom_smooth(method='lm', formula= y~x) +
  ylim(0,1) +
  ggtitle('UCs predicting concentration of score')

lm_model <- lm(gini_score_dist ~ contributors, data = df_subs)
summary(lm_model)

lm_model <- lm(gini_score_dist ~ contributors + interval + is_city + is_country + is_continent, data = df_subs)
summary(lm_model)
"

ggplot(df_subs[!is.na(df_subs$turnover),], aes(x=contributors, y=turnover)) +
  geom_point(aes(color = factor(group))) +
  geom_smooth(method='lm', formula= y~x) +
  scale_x_continuous(trans='log2') +
  ylim(0,1) +
  ggtitle("UCs predicting turnover")+
  ylab("Turnover") +
  xlab("Unique contributors/Interval (log2)")+
  scale_color_manual(name = "Group", values=category_colors, labels=category_labels)

ggsave(path = "comments_files/figure-svg/", filename = "turnover_distribution.svg", device='svg')
ggsave(path = "comments_files/figure-png/", filename = "turnover_distribution.png", device='png')

lm_model <- lm(turnover ~ log_contributors + interval, data = df_subs)
summary(lm_model)


lm_model <- lm(turnover ~ log_contributors + interval + is_city + is_country_native + is_country_bi + is_continent, data = df_subs)
summary(lm_model)

lm_model <- lm(turnover ~ is_city + is_country_native + is_country_bi + is_continent, data = df_subs)
summary(lm_model)

lm_model <- lm(turnover ~ gini_comment_dist, data = df_subs)
summary(lm_model)

```